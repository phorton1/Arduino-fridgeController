
#if !WITH_TSENSE
	void setFakeTemperatures()
	{
		// WORKING IN more granular CENTIGRADE, displaying in FARENHEIT
		// create dummy numbers for testing logging and chart
		// the mech_therm and comp_rpms come on at certain setpoints

		#define ON_TEMPERATURE	 	-12.0	// Centigrade
		#define OFF_TEMPERATURE  	-20.0	// Centigrade
		#define MECH_TEMPERATURE 	-16.0	// Centigrade

		static bool started = 0;
		static float temp1_delta;
		static float temp2_delta;

		if (!started)
		{
			started = 1;
			cur_temperature1 = -19.0;	// Centigrade
			temp1_delta = 1;

			cur_temperature2 = farenheitToCentigrade(100.0);
			temp2_delta = -1;
		}
		else
		{
			#if DEBUG_TSENSE>1
				LOGD("   delta1=%0.3fF delta2=%0.3fF",
					 centigradeToFarenheit(temp1_delta),
					 centigradeToFarenheit(temp2_delta));
			#endif

			cur_temperature1 += temp1_delta;
			if (cur_temperature1 > farenheitToCentigrade(80.0))		// ambient
				cur_temperature1 = farenheitToCentigrade(80.0);

			cur_temperature2 += temp2_delta;
			if (cur_temperature2 < farenheitToCentigrade(80.0))		// ambient
				cur_temperature2 = farenheitToCentigrade(80.0);
			if (cur_temperature2 > farenheitToCentigrade(212.0))	// boiling!
				cur_temperature2 = farenheitToCentigrade(212.0);
		}

		if (!cur_comp_rpm && cur_temperature1>ON_TEMPERATURE)
			cur_comp_rpm = 2400;	// better for graphing
		if (cur_comp_rpm && cur_temperature1<OFF_TEMPERATURE)
			cur_comp_rpm = 0;
		cur_mech_therm = cur_temperature1 > MECH_TEMPERATURE ? 1 : 0;

		float tdelta1 = random(100);
		tdelta1 /= 500;		// 0 - 0.20
		tdelta1 += 0.1;		// 0.1 - 0.30
		if (cur_comp_rpm)
			tdelta1 = -tdelta1;
		temp1_delta += tdelta1;
		if (temp1_delta > 2.0)
			temp1_delta = 2.0;
		if (temp1_delta < -2.0)
			temp1_delta = -2.0;

		if (cur_comp_rpm && temp2_delta < 0)
			temp2_delta = 0;
		if (!cur_comp_rpm && temp2_delta > 0)
			temp2_delta = 0;

		float tdelta2 = random(100);
		tdelta2 /= 500;		// 0 - 0.20
		tdelta2 += 0.1;		// 0.1 - 0.30
		if (!cur_comp_rpm)
			tdelta2 = -tdelta2;
		temp2_delta += tdelta2;
		if (temp2_delta > 2.0)
			temp2_delta = 2.0;
		if (temp2_delta < -2.0)
			temp2_delta = -2.0;

	}
#endif

	//--------------------------------------
	// test compressor speed
	//--------------------------------------

#if WITH_PWM && TEST_COMPRESSOR_SPEED

	static uint32_t last_test;
	if (now - last_test > 50)
	{
		last_test = now;

		static bool test_sw;
		bool sw = !digitalRead(PIN_BUTTON1);

		static bool test_running;
		static int  desired_rpm;
		static uint32_t last_test_time;

		if (test_sw != sw)
		{
			test_sw = sw;

			#define DO_TEST_SEQUENCE	0
			#if DO_TEST_SEQUENCE

				display(0,"TEST(%s)",test_sw?"STARTING":"OFF");
				desired_rpm = 1750;		// will be incremented at start
				last_test_time = 0;
				test_running = test_sw;
				ledcWrite(PWM_CHANNEL, 0);

			#else	// simply turn the PWM on or off

				display(0,"TURNING_PUMP(%s)",test_sw?"ON":"OFF");
				int duty = test_sw ? rpmToDuty(2000) : 0;
				ledcWrite(PWM_CHANNEL, duty);

			#endif
		}

		if (test_running && now-last_test_time > 10000)
		{
			desired_rpm += 250;
			if (desired_rpm > 3500)
			{
				test_running = 0;
				display(0,"TEST FINISHED!",0);
				ledcWrite(PWM_CHANNEL, 0);
			}
			else
			{
				int duty = rpmToDuty(desired_rpm);
				ledcWrite(PWM_CHANNEL, duty);
				last_test_time = now;
			}
		}
	}
#endif	// TEST_COMPRESSOR_SPEED



//----------------------------------------------------
// ESP32 issues - for lack of a better place
//----------------------------------------------------
// In the middle of development I got a bunch of ESP32-S3-ZERO boards,
// and wanted to try them.  Got totally sidetracked into updating
// from ESP32 Core 1_0_6 to most recent 3_0_4 after I discovered that
// my Arduino IDE 1.8.13 did not support the S3 board.
//
// First installing Arduino IDE 2.3.2 on a new laptop, and the 3_0_4
// core, I was able to get an LED to blink.  Lots of work to figure
// out how to get a myIOT test program to run on the little board,
// before finally getting to uploading /data to the SPIFFS.
// The SPIFFS upload tool is not supported in Arduino 2.0, so
// I tried it from IDE 1.18.3, but of course, the old esp32tool
// doesn't know about the S3.  Modified my "upload_spiffs.pm" script
// and got it to work, but not before wiping out my /Users/Patrick
// AppData/Local/Arduino15 esp32 stuff.  So an emergency restore of THAT
// from a hard disk archive, and then installing 3_0_4 over that,
// and jiggling around, I got the test app to run on the S3, BUT
// it is not a reliable little platform and I could never get it
// to fully work.  I digressed to a WebServer only test program
// and had to mess with serial ports, and many things before giving
// up in exhaustion at 4:00am.
//
// Today I started by carefully identifying the changes to myIOT
// and ESP32SSDP that I had to make tot get it to compile, and
// digging up some compile defines that I could drive the build
// with. Got it all nice and then built the fridgeController
// with 3_0_4.  Builds fine; runs not so good.
//
// Apparently there are more Serial Port kludges in 3_0_4, and
// right now I am struggling to even debug fridgeController because
// the serial port output is gobbledy-gook, on top of which I'm
// getting a boot time error:
//
//	E (131) esp_co?fx_dump_flash: Incorrect size of core dump image: 6619237
//
// At least I verified that I can go back to 1_0_6 and the fridgeController
// builds and seems to work as before.  In /Users/Patrick/AppData/Local
// there are two switchable copies of Arduino15 ... one is 1_0_6 and
// the other is 3_0_4 and the one not in use is named appropriately.
// There are also backup copies of each in /junk/maybe_save.
//
// As a result, there are also multiple copies of preferences.txt
// checked in and I have added an Arduino/_esp32  'test' directory
// to localize the many test programs written in this foray.
//
// At this point, I cannot conclusively say it is a good idea to go
// to 3_0_4.  It is definitely a bad idea to go to Arduino IDE 2, or
// I risk not only all the ESP32 stuff (myIOT and FluidNC), but also
// all the teensy stuff, which is already in flux.
//
// Compiling cnc_3018 against 3_0_4 was even worse.  Starting with
// src/StackTrace/debug_helpers.cpp, which failed on, but does not need
//			#    include "soc/cpu.h"
// there are problems with basic ESP32 includes, that exist, but are not
// compiling correctly in-and-around "assert()" and a failure to include
// <cassert>, as well as Strings and flash memory:
//
// - src\spindles\spindle.h:83:38: error: cannot bind non-const lvalue reference of type 'IPAddress&' to an rvalue of type 'IPAddress'
// - src\spindles\spindle.h:83:38: error: invalid conversion from 'int' to 'const __FlashStringHelper*' [-fpermissive]
// - rc/Machine/Homing.h:43:25: error: no matching function for call to 'item(const char [6], int&)
//
// and many, many, other problems.


