<head>
<title>fridgeController Temperature Chart</title>
<link href="/spiffs/jquery.jqplot.min.css" rel="stylesheet">
	<!-- http://www.jqplot.com/ -->
<script src="/jquery-3.6.0.min.js"></script>
<script src="/spiffs/jquery.jqplot.min.js"></script>
<script src="/spiffs/jqplot.dateAxisRenderer.js"></script>
<script src="/spiffs/jqplot.cursor.js"></script>
<script src="/spiffs/jqplot.highlighter.js"></script>
<!-- jqplot.enhancedLegendRenderer.js renamed to jqplot.legendRenderer.js -->
<!-- cuz spiff max filename length -->
<script src="/spiffs/jqplot.legendRenderer.js"></script>
<body>

<div id="chartdiv" style="height:400px;width:800px; "></div>

<button onclick="get_chart_data()">update_chart</button>
&nbsp;&nbsp;&nbsp;

<label for="refresh_interval">Refresh Interval:</label>
<input id="refresh_interval" type='number' value='0' min='0'>

&nbsp;&nbsp;&nbsp;

<label for="chart_period">Chart Period:</label>
<select name="period" id="chart_period" onchange="get_chart_data()">
	<option value="0">All</option>
	<option value="60">Minute</option>
	<option value="900">15 Minutes</option>
	<option value="3600" selected="selected">Hour</option>
	<option value="10800">3 Hours</option>
	<option value="43200">12 Hours</option>
	<option value="86400">Day</option>
	<option value="172800">2 Days</option>
	<option value="259200">3 Days</option>
	<option value="604800">Week</option>
	<option value="2592000">Month</option>
	<option value="5184000">2 Months</option>
	<option value="7776000">3 Months</option>
	<option value="31536000">Year</option>
</select>
<br>
<textarea id='info' rows='5' cols='80'></textarea>
	


<script>

const use_zoom = true;


var plot;
var chart_header;
var refresh_timer;

function determineNumTicks()
	// using the column tick_intervals and the raw min and max
	// for each value, determine the number of ticks that will
	// completely encapsulate the data, then go back and set
	// the min and max of each column to the appropriate value.
{
	var num_ticks = 0;
	for (var i=0; i<chart_header.num_cols; i++)
	{
		var col = chart_header.col[i];
		var min = col.min;
		var max = col.max;
		var interval = col.tick_interval;

		var low = Math.floor(parseInt((min-interval+1) /interval));
		var high = Math.ceil(parseInt((max+interval-1) /interval));

		var new_min = low * interval;
		// var new_max = high * interval;

		var ticks = high - low;
		if (ticks > num_ticks)
			num_ticks = ticks;

		// col['num_ticks'] = ticks;
		col.min = new_min;
		// col.max = new_max;
	}

	// now assign the max so that every one uses the same number of ticks

	for (var i=0; i<chart_header.num_cols; i++)
	{
		var col = chart_header.col[i];
		var min = col.min;
		var interval = col.tick_interval;

		var max = min + num_ticks * interval;
		col.max = max;
	}
	
	// return the number of ticks

	return num_ticks + 1;
}



function do_the_plot(data,num_recs,secs)
{
	if (plot)
		plot.destroy();

	// many of these options will end up being application specific.
	// I'm not sure to what degree I want to have each app know about
	// jqplot. They currently don't know much (only that 2400 is better
	// for charting rpms than 2500), but I can see a case, especially
	// with the notion of app specific "widgets", for the apps to becom
	// much more aware of jqplot, and for that matter, bootstrap and jq.

	var info = '';
	var col = chart_header.col;
	var num_ticks = determineNumTicks();

	var options = {

		title: chart_header.name,
		seriesDefaults: { showMarker: false, },

		legend : {
			renderer: $.jqplot.EnhancedLegendRenderer,
			show: true,
			showLabels: true,
			rendererOptions: {
				numberRows: 1,

				// not useful as I set the chart ticks
				// would need to do more sophisticated
				// stuff to get the idea that we redraw
				// the chart when a series comes or goes.
				//
				// seriesToggleReplot: true,
			},
		},
		series: [],
		axes:{
			xaxis:{
				renderer:$.jqplot.DateAxisRenderer,
				// jqplot does a good job of handling the time axis
				// tickOptions:{formatString:'%H:%M:%S'},
				// tickInterval: secsToInterval(secs),
			},
		},	// axes
	};	// options


	if (use_zoom)
	{
		options['cursor'] = {
			zoom:true,
			looseZoom: true,
			showTooltip:true,
			followMouse: true,
			showTooltipOutsideZoom: true,
			constrainOutsideZoom: false
		};
	}


	for (var i=0; i<chart_header.num_cols; i++)
	{
		var axis_name = 'y';
		if (i>0) axis_name += (i+1);
		axis_name += 'axis';

		info += "col[" + i + "]" + col[i].name;
		info += " min:" + col[i].min + " max:" + col[i].max;
		info += "\n";

		options.axes[ axis_name ] = {
			pad: 1.2,
			show: true,
			label: col[i].name,
			showLabel : false,	// true,
			min: col[i].min,
			max: col[i].max,
			numberTicks: num_ticks, // col[i].num_ticks,	// chart_header.num_ticks,
		};
		options.series[i] = {
			label: col[i].name,
			shadow : false,
			lineWidth: 2,
			// yaxis : axis_name,
		};
	}

	// scale the values to the 0th axis

	if (true && chart_header.num_cols > 1)
	{
		var global_min = col[0].min;
		var global_max = col[0].max;
		var global_range = global_max - global_min;

		for (var i=1; i<chart_header.num_cols; i++)
		{
			var min = col[i].min;
			var max = col[i].max;
			var range = max - min;
			for (var j=0; j<num_recs; j++)
			{
				var series = data[i];
				var rec = series[j];
				var val = rec[1];
				val -= min;
				val /= range;
				val *= global_range;
				val += global_min;
				rec[1] = val;
			}
		}
	}


	document.getElementById("info").value = info;

	plot = $.jqplot('chartdiv', data, options);

	// reverse the order of the canvasas so that
	// the most important one (zero=temperature1)
	// is on top.

	for (var i=chart_header.num_cols-1; i>=0; i--)
	{
		plot.moveSeriesToFront(i);
	}


	// add a click handler to the enhancedLegendRenderer
	// legend swatches so that when a series is made
	// visible it is moved to the top, so toggling
	// them on and off effectively lets the user set
	// the z-order ..
	
	var i=0;
	$('td.jqplot-table-legend-swatch').each(function(){
		$(this).bind('click',{index:i},function(ev){
			var index = ev.data.index;
			// alert("toggle " + index);
			plot.moveSeriesToFront(index);
		});
		i++;
	});

	var refresh = document.querySelector("#refresh_interval");
	if (refresh.value > 0)
		refresh_timer = setTimeout(get_chart_data,refresh.value * 1000);

}




function create_chart_data(abuffer,secs)
	// Decode the binary data into jqPlot compatible arrays of actual data.
	// The binary starts with a uin32_t for the number of records, followed
	// by that number of records consisting of a uint32 timestamp followed
	// by a nuumber of 32 bit fields of specific types.
	//
	// As we do this we also set working min and max values on each column.
{
    const view = new DataView(abuffer);

	var offset = 0;
	const num_recs = view.getUint32(0, true);
	offset += 4;

	var min_time;
	var max_time;

	// console.log('num_recs:', num_recs);

	var col = chart_header.col;

	var data = [];
	for (var i=0; i<chart_header.num_cols; i++)
	{
		data[i] = [];
		col[i]['min'] = 0;
		col[i]['max'] = 0;
	}

	for (var i=0; i<num_recs; i++)
	{
		// console.log('   rec[' + i + ']  offset(' + offset + ')');
		const ts = view.getUint32(offset, true); // true for little-endian
		offset += 4;

		if (i == 0)
		{
			min_time = ts;
			max_time = ts;
		}
		else
		{
			if (ts < min_time)
				min_time = min_time;
			if (ts > max_time)
				max_time = ts;
		}


		// debugging
		// const dt = new Date(ts * 1000);
		// console.log('      dt=' + dt);
		
		for (var j=0; j<chart_header.num_cols; j++)
		{
			var val;
			const typ = col[j].type;
			if (typ == 'float')
				val = view.getFloat32(offset, true);
			else if (typ == 'int32_t')
				val = view.getInt32(offset, true);
			else
				val = view.getUint32(offset, true);
			offset += 4;

			if (i == 0)
			{
				col[j].min = val;
				col[j].max = val;
			}
			else
			{
				if (val < col[j].min) col[j].min = val;
				if (val > col[j].max) col[j].max = val;
			}

			// console.log('      off(' + offset + ") " + col[j].name + "(" + typ + ") = " + val);

			data[j].push([ ts * 1000, val]);
		}
	}

	do_the_plot(data,num_recs,max_time-min_time);
}




function get_chart_data()
{
	clearTimeout(refresh_timer);
	
	var secs = document.getElementById("chart_period").value;

	var xhr = new XMLHttpRequest();
	xhr.open('GET', '/custom/chart_data?secs=' + secs, true);
	xhr.responseType = 'arraybuffer';
	xhr.onload = function(e)
	{
		create_chart_data(this.response);
	};

	xhr.send();
}



function update_chart()
{
	var xhr_init = new XMLHttpRequest();
	xhr_init.onreadystatechange = function()
	{
		if (this.readyState == 4 && this.status == 200)
		{
			chart_header = JSON.parse(this.responseText);
			get_chart_data();
		}
    }
	xhr_init.open('GET', '/custom/chart_header', true);
	xhr_init.send();
}





$(document).ready(function() {
	$.jqplot.config.enablePlugins = true;
    // For these examples, don't show the to image button.
    $.jqplot._noToImageButton = true;

	update_chart();
});


</script>

</body>
